<!DOCTYPE html>
<html>
<head><title>Control Your Character</title></head>
<body style="margin:0;overflow:hidden;">
  <canvas id="game" width="1000" height="500" style="border:1px solid black;"></canvas>
  <div id="loginOverlay" style="position:absolute;top:0;left:0;width:1000px;height:500px;
      display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:10;">
    <input id="usernameInput" type="text" placeholder="Enter username"
           style="font-size:20px;padding:10px;width:60%;" />
    <button id="usernameBtn" style="font-size:20px;margin-left:10px;">Go</button>
  </div>
  <script src="https://interactive-website-9620.onrender.com/socket.io/socket.io.js"></script>
  <script>
    const socket = io("https://interactive-website-9620.onrender.com");
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    //ctx.imageSmoothingEnabled = false;

    const box_1_img = new Image();
    box_1_img.src = '/assets/obstacles/box_1.png';
    const idleImg = new Image();
    idleImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Idle/Slime1_Idle_body.png';
    const runImg = new Image();
    runImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Run/Slime1_Run_body.png';

    const imgsPromise = Promise.all([
      new Promise(r => box_1_img.onload = r),
      new Promise(r => idleImg.onload = r),
      new Promise(r => runImg.onload = r),
    ]);

    const boxes = [
      {x: 0, y: 400, width: 20, height: 20},
      {x: 80, y: 450, width: 20, height: 20},
      {x: 100, y: 450, width: 20, height: 20},
      {x: 120, y: 450, width: 20, height: 20},
      {x: 90, y: 350, width: 20, height: 20},
      {x: 110, y: 350, width: 20, height: 20},
      {x: 200, y: 400, width: 20, height: 20},
      {x: 300, y: 480, width: 20, height: 20},
      {x: 420, y: 420, width: 20, height: 20},
      {x: 440, y: 420, width: 20, height: 20},
      {x: 550, y: 380, width: 20, height: 20},
      {x: 620, y: 340, width: 20, height: 20},
      {x: 645, y: 360, width: 20, height: 20},
      {x: 670, y: 340, width: 20, height: 20},
      {x: 750, y: 380, width: 20, height: 20},
      {x: 770, y: 380, width: 20, height: 20},
      {x: 790, y: 380, width: 20, height: 20},
      {x: 750, y: 440, width: 20, height: 20},
      {x: 770, y: 440, width: 20, height: 20},
      {x: 790, y: 440, width: 20, height: 20},
      {x: 860, y: 400, width: 20, height: 20},
      {x: 860, y: 380, width: 20, height: 20},
      {x: 980, y: 380, width: 20, height: 20},
    ];

    const player = {
      x: 200, y: 480, width: 20, height: 20,
      Yv: 0, Yforce: 0, YforceMax: 0.5,
      Xv: 0, gravity: 500, onGround: false,
      friction: 1200, speedMax: 150,
      running: false, jumping: false,
      username: "", action: "idle"
    };

    const anim = { fw: 64, fh: 64, count: 6, frame: 0, row: 0 };
    let lastTs = 0, frameTimer = 0, moving = false;

    document.getElementById('usernameBtn').onclick = () => {
      const name = document.getElementById('usernameInput').value.trim() || 'Player1';
      player.username = name;
      socket.emit('new-Player', { id: socket.id, name });
      document.getElementById('loginOverlay').style.display = 'none';
      canvas.focus();
    };

    function handleCollision(dt) {
      let acted = false;
      for (const b of boxes) {
        const px = player.x, py = player.y, pw = player.width, ph = player.height;
        const { x: bx, y: by, width: bw, height: bh } = b;

        if (px + pw > bx && px < bx + bw &&
            py + ph <= by && py + ph + player.Yv * dt >= by) {
          player.y = by - ph; player.Yv = 0; player.onGround = true; acted = true;
        }
        else if (px + pw <= bx && px + pw + player.Xv * dt >= bx &&
                 py + ph > by && py < by + bh) {
          player.x = bx - pw; player.Xv = 0; acted = true;
        }
        else if (px >= bx + bw && px + player.Xv * dt <= bx + bw &&
                 py + ph > by && py < by + bh) {
          player.x = bx + bw; player.Xv = 0; acted = true;
        }
        else if (px + pw > bx && px < bx + bw &&
                 py >= by + bh && py + player.Yv * dt <= by + bh) {
          player.Yv = 10; acted = true;
        }
        if (acted) break;
      }
    }

    function update(dt) {
      frameTimer += dt;
      if (frameTimer >= 0.1) {
        anim.frame = (anim.frame + 1) % anim.count;
        frameTimer = 0;
      }
      player.onGround = false;
      player.Yv += player.gravity * dt;
      player.y += player.Yv * dt;
      handleCollision(dt);

      if (player.y + player.height >= canvas.height) {
        player.y = canvas.height - player.height;
        player.Yv = 0;
        player.onGround = true;
      }

      player.x = Math.max(0, Math.min(player.x + player.Xv * dt, canvas.width - player.width));

      if (player.onGround && !moving && Math.abs(player.Xv) < 30) {
        player.Xv = 0;
      } else if (!moving && player.Xv !== 0) {
        player.Xv += (player.Xv > 0 ? -player.friction : player.friction) * dt;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const b of boxes) {
        ctx.drawImage(box_1_img, b.x, b.y, b.width, b.height);
      }
      const sprite = player.action === 'run' ? runImg : idleImg;
      ctx.drawImage(sprite,
        anim.frame * anim.fw, anim.row * anim.fh, anim.fw, anim.fh,
        player.x - 20, player.y - 20, anim.fw, anim.fh
      );
      ctx.font = '16px Arial';
      ctx.fillStyle = 'blue';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(player.username, player.x + player.width / 2, player.y - 5);

      socket.emit('move', {
        x: player.x,
        y: player.y,
        frameCount: anim.count,
        frameIndex: anim.frame,
        frameRow: anim.row,
        username: player.username,
        emote: player.action
      });
    }

    canvas.addEventListener('keydown', e => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp'].includes(e.key)) moving = true;
      if (e.key === 'ArrowUp' && player.onGround) {
        player.Yv = -200;
        player.jumping = true;
      }
      if (e.key === 'ArrowRight' && player.onGround) {
        player.action = 'run';
        anim.count = 8;
        anim.row = 3;
        player.Xv = player.speedMax;
      }
      if (e.key === 'ArrowLeft' && player.onGround) {
        player.action = 'run';
        anim.count = 8;
        anim.row = 2;
        player.Xv = -player.speedMax;
      }
    });

    canvas.addEventListener('keyup', e => {
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp'].includes(e.key)) moving = false;
      if (e.key === 'ArrowUp') player.jumping = false;
      if (['ArrowLeft', 'ArrowRight'].includes(e.key)) {
        player.action = 'idle';
        anim.frame = 0;
        anim.count = 6;
        anim.row = 0;
      }
    });

    imgsPromise.then(() => {
      lastTs = performance.now();
      canvas.focus();
      requestAnimationFrame(now => {
        lastTs = now;
        function loop(ts) {
          const dt = (ts - lastTs) / 1000;
          lastTs = ts;
          update(dt);
          draw();
          requestAnimationFrame(loop);
        }
        loop(lastTs);
      });
    });
  </script>
</body>
</html>
