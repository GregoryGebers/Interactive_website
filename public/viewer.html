<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Control Your Character</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* Twitch stream behind everything */
    #twitchBg {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      border: 0;
      z-index: 0;
      pointer-events: none; /* important: game receives clicks/keys */
    }

    /* Fullscreen canvas visually, but internal world stays 1000x500 */
    #game {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      border: none;
      outline: none;
      z-index: 2;
      image-rendering: pixelated; /* nice for pixel art */
      display: block;
    }

    /* Fullscreen login overlay */
    #loginOverlay {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 3;
      gap: 10px;
      padding: 20px;
      box-sizing: border-box;
    }

    #usernameInput {
      font-size: 20px;
      padding: 10px;
      width: min(600px, 70vw);
      max-width: 90vw;
    }

    #usernameBtn {
      font-size: 20px;
      padding: 10px 16px;
      cursor: pointer;
    }

    /* Optional fullscreen button */
    #fsBtn {
      position: fixed;
      right: 12px;
      top: 12px;
      z-index: 5;
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.9;
    }
  </style>
</head>

<body>
  <!-- IMPORTANT: Replace parent= with your actual domain.
       For Render: parent=interactive-website-9620.onrender.com
       For local testing: parent=localhost
  -->
  <iframe
    id="twitchBg"
    src="https://player.twitch.tv/?channel=eberhex&parent=interactive-website-9620.onrender.com&muted=true"
    allowfullscreen="true"
    frameborder="0">
  </iframe>

  <button id="fsBtn" type="button">Fullscreen</button>

  <!-- Keep playable area fixed at 1000x500 -->
  <canvas id="game" width="1000" height="500" tabindex="0"></canvas>

  <div id="loginOverlay">
    <input id="usernameInput" type="text" placeholder="Enter username" />
    <button id="usernameBtn" type="button">Go</button>
  </div>

  <script src="https://interactive-website-9620.onrender.com/socket.io/socket.io.js"></script>

  <script>
    const socket = io("https://interactive-website-9620.onrender.com");

    // ===== Fixed "world" size (do not change playable area) =====
    const WORLD_W = 1000;
    const WORLD_H = 500;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    // Ensure internal resolution matches the playable area
    canvas.width = WORLD_W;
    canvas.height = WORLD_H;

    canvas.focus();

    // ===== Assets =====
    const box_1_img = new Image();
    box_1_img.src = '/assets/obstacles/box_1.png';

    const trampoline_img = new Image();
    trampoline_img.src = '/assets/obstacles/trampoline.png';

    const idleImg = new Image();
    idleImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Idle/Slime1_Idle_body.png';

    const runImg = new Image();
    runImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Run/Slime1_Run_body.png';

    const coinImg = new Image();
    coinImg.src = '/assets/obstacles/coin.png';

    let img = idleImg;

    const animations = {
      frameWidth: 64,
      frameHeight: 64,
      frameCount: 6,
      currentFrame: 0,
      frameRow: 0
    };

    // ===== World Objects =====
    const boxes = [
      {x: 0, y: 400, width: 20, height: 20},
      {x: 80, y: 450, width: 20, height: 20},
      {x: 100, y: 450, width: 20, height: 20},
      {x: 120, y: 450, width: 20, height: 20},
      {x: 90, y: 350, width: 20, height: 20},
      {x: 110, y: 350, width: 20, height: 20},
      {x: 200, y: 400, width: 20, height: 20},
      {x: 300, y: 480, width: 20, height: 20},
      {x: 420, y: 420, width: 20, height: 20},
      {x: 440, y: 420, width: 20, height: 20},
      {x: 550, y: 380, width: 20, height: 20},
      {x: 620, y: 340, width: 20, height: 20},
      {x: 645, y: 360, width: 20, height: 20},
      {x: 670, y: 340, width: 20, height: 20},
      {x: 750, y: 380, width: 20, height: 20},
      {x: 770, y: 380, width: 20, height: 20},
      {x: 790, y: 380, width: 20, height: 20},
      {x: 750, y: 440, width: 20, height: 20},
      {x: 770, y: 440, width: 20, height: 20},
      {x: 790, y: 440, width: 20, height: 20},
      {x: 860, y: 400, width: 20, height: 20},
      {x: 860, y: 380, width: 20, height: 20},
      {x: 980, y: 380, width: 20, height: 20},
    ];

    const player = {
      x: 100,
      y: 480,
      width: 20,
      height: 20,
      Yv: 0,
      Yforce: 0,
      YforceMax: 0.5,
      Xv: 0,
      gravity: 500,
      onGround: false,
      friction: 1200,
      speedMax: 150,
      running: false,
      jumping: false,
      username: "",
      action: "idle",
      score: 0
    };

    let lastTime = performance.now();
    let frameTimer = 0;
    let animationStopper = false;
    const frameInterval = 0.1;

    let coin = null;
    socket.on("coin", data => {
      coin = data;
      console.log("Coin received:", data.x, data.y);
    });

    // ===== Viewport scaling (fullscreen display, fixed world) =====
    function applyViewportTransform() {
      // Fit the entire 1000x500 world into the screen, letterbox if needed
      const scale = Math.min(window.innerWidth / WORLD_W, window.innerHeight / WORLD_H);
      const offsetX = (window.innerWidth - WORLD_W * scale) / 2;
      const offsetY = (window.innerHeight - WORLD_H * scale) / 2;

      // Draw world coordinates scaled into screen coordinates
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      return { scale, offsetX, offsetY };
    }

    function clearScreen() {
      // Clear in screen space (identity transform)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }

    window.addEventListener('resize', () => {
      // No world change, just redraw with new scale
      draw();
    });

    // ===== Login overlay =====
    usernameprompt();
    function usernameprompt() {
      const overlay = document.getElementById('loginOverlay');
      const input = document.getElementById('usernameInput');
      const button = document.getElementById('usernameBtn');

      button.addEventListener('click', () => {
        const name = input.value.trim() || 'Player1';
        player.username = name;

        socket.on('connect', () => {
          socket.emit('new-player', { id: socket.id, name });
        });

        overlay.style.display = 'none';
        canvas.focus();
      });
    }

    // ===== Game Loop =====
    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      update(deltaTime);
      draw();

      requestAnimationFrame(gameLoop);
    }

    function update(deltaTime) {
      // Animation frames
      frameTimer += deltaTime;
      if (frameTimer >= frameInterval) {
        animations.currentFrame = (animations.currentFrame + 1) % animations.frameCount;
        frameTimer = 0;
      }

      // Collisions
      for (const box of boxes) {
        const onBottom =
          player.y - player.height <= box.y - 1 &&
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y > box.y;

        const onTop =
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y + player.height <= box.y &&
          player.y + player.height + player.Yv * deltaTime >= box.y;

        const LeftSide =
          player.x + player.width >= box.x &&
          player.x + player.width <= box.x + box.width &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        const RightSide =
          player.x <= box.x + box.width &&
          player.x >= box.x &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        if (onTop) {
          player.y = box.y - player.height;
          player.Yv = 0;
          player.onGround = true;
          break;
        } else {
          player.onGround = false;
        }

        if (onBottom) {
          player.Yv = 10;
        }

        if (LeftSide) {
          player.Xv = -80;
        }
        if (RightSide) {
          player.Xv = 80;
        }
      }

      // Coin
      if (coin != null) {
        const coin_touching =
          player.x < coin.x + 10 &&
          player.x + player.width > coin.x &&
          player.y < coin.y + 10 &&
          player.y + player.height > coin.y;

        if (coin_touching) {
          console.log("received a coin");
          coin = null;
          player.score++;
          socket.emit("coin_taken");
        }
      }

      // Gravity and floor
      if (!player.onGround) {
        player.Yv += player.gravity * deltaTime;
        player.y += player.Yv * deltaTime;
      }

      if (player.y + player.height >= WORLD_H) {
        player.y = WORLD_H - player.height;
        player.Yv = 0;
        player.onGround = true;
      }

      // Friction / idle
      if (player.onGround) {
        if (player.jumping) {
          player.Yforce += deltaTime;
        }

        if (player.Xv >= -29 && player.Xv <= 29 && player.running === false) {
          player.Xv = 0;
          if (animationStopper === false) {
            img = idleImg;
            player.action = "idle";
            animations.currentFrame = 0;
            animations.frameCount = 6;
            animations.frameRow = 0;
            animationStopper = true;
          }
        }

        if (player.running === false && player.Xv > 0) {
          player.Xv -= player.friction * deltaTime;
        } else if (player.running === false && player.Xv < 0) {
          player.Xv += player.friction * deltaTime;
        }
      }

      // Horizontal movement
      player.x += player.Xv * deltaTime;

      if (player.x <= 0) {
        player.x = 0;
        player.Xv = 80;
      } else if (player.x + player.width >= WORLD_W) {
        player.x = WORLD_W - player.width;
        player.Xv = -80;
      }
    }

    function setObjects() {
      for (const box of boxes) {
        ctx.drawImage(box_1_img, box.x - 5, box.y - 5, box.width + 12, box.height + 12);
      }
      if (coin != null) {
        ctx.drawImage(coinImg, coin.x, coin.y, 20, 20);
      }
    }

    function draw() {
      clearScreen();
      applyViewportTransform();

      // Draw world
      setObjects();

      // Player sprite
      ctx.drawImage(
        img,
        animations.currentFrame * animations.frameWidth,
        animations.frameRow * animations.frameHeight,
        animations.frameWidth, animations.frameHeight,
        player.x - 20, player.y - 20,
        animations.frameWidth, animations.frameHeight
      );

      // Text (world space)
      ctx.font = '16px Arial';
      ctx.fillStyle = 'blue';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';

      ctx.fillText(player.username, player.x + player.width / 2, player.y - 5);

      // Score, anchored inside world
      ctx.textAlign = 'left';
      ctx.fillText("Current score: " + player.score, 10, WORLD_H - 10);

      socket.emit("move", {
        x: player.x,
        y: player.y,
        frameCount: animations.frameCount,
        frameIndex: animations.currentFrame,
        frameRow: animations.frameRow,
        username: player.username,
        emote: player.action,
        score: player.score
      });
    }

    // ===== Input =====
    canvas.addEventListener('keydown', e => {
      if (e.key === "ArrowRight" && player.onGround) {
        player.action = "run";
        if (player.running === false) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 3;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = player.speedMax;
      }

      if (e.key === "ArrowLeft" && player.onGround) {
        player.action = "run";
        if (player.running === false) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 2;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = -1 * player.speedMax;
      }

      if (e.key === "ArrowUp") {
        if (player.onGround === true) {
          player.jumping = true;
        }
      }

      socket.emit("move", {
        x: player.x,
        y: player.y,
        frameCount: animations.frameCount,
        frameIndex: animations.currentFrame,
        frameRow: animations.frameRow,
        username: player.username,
        emote: player.action,
        score: player.score
      });
    });

    canvas.addEventListener('keyup', e => {
      if (e.key === "ArrowRight") {
        player.running = false;
      }
      if (e.key === "ArrowLeft") {
        player.running = false;
      }

      if (e.key === "ArrowUp") {
        if (player.onGround) {
          player.jumping = false;
          player.onGround = false;
          if (player.Yforce > player.YforceMax) {
            player.Yforce = player.YforceMax;
          }
          player.Yv -= player.Yforce * 180 + 200;
          player.Yforce = 0;
        }
      }

      socket.emit("move", {
        x: player.x,
        y: player.y,
        frameCount: animations.frameCount,
        frameIndex: animations.currentFrame,
        frameRow: animations.frameRow,
        username: player.username,
        emote: player.action,
        score: player.score
      });
    });

    // Keep focus on canvas for key events
    window.addEventListener('click', () => canvas.focus());

    // Fullscreen button (user interaction required by browsers)
    document.getElementById('fsBtn').addEventListener('click', async () => {
      try {
        await document.documentElement.requestFullscreen();
        canvas.focus();
      } catch (err) {
        console.log("Fullscreen failed:", err);
      }
    });

    // Start loop once at least one critical image is ready
    idleImg.onload = () => requestAnimationFrame(gameLoop);
  </script>
</body>
</html>



