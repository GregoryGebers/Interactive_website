<!DOCTYPE html>
<html>
<head><title>Control Your Character</title></head>
<body style="margin:0;overflow:hidden;">
  <canvas id="game" width="1000" height="500" style="border:1px solid black;"></canvas>
  <div id="loginOverlay" style="position:absolute;top:0;left:0;width:1000px;height:500px;
      display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:10;">
    <input id="usernameInput" type="text" placeholder="Enter username"
           style="font-size:20px;padding:10px;width:60%;" />
    <button id="usernameBtn" style="font-size:20px;margin-left:10px;">Go</button>
  </div>
  <script src="https://interactive-website-9620.onrender.com/socket.io/socket.io.js"></script>
  <script>
    const socket = io("https://interactive-website-9620.onrender.com");
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const resources = {
      box: '/assets/obstacles/box_1.png',
      idle: '/assets/characters/.../Slime1_Idle_body.png',
      run: '/assets/characters/.../Slime1_Run_body.png'
    };
    const imgs = {};
    const loadImages = (sources) => Promise.all(Object.entries(sources).map(
      ([key, src]) => new Promise(resolve => {
        const img = new Image();
        img.src = src;
        img.onload = () => (imgs[key] = img, resolve());
      })
    ));

    const boxes = [
       {x: 0, y: 400, width: 20, height: 20},
    {x: 80, y: 450, width: 20, height: 20},
    {x: 100, y: 450, width: 20, height: 20},
    {x: 120, y: 450, width: 20, height: 20},
    {x: 90, y: 350, width: 20, height: 20},
    {x: 110, y: 350, width: 20, height: 20},
    {x: 200, y: 400, width: 20, height: 20},
    {x: 300, y: 480, width: 20, height: 20},
    {x: 420, y: 420, width: 20, height: 20},
    {x: 440, y: 420, width: 20, height: 20},
    {x: 550, y: 380, width: 20, height: 20},
    {x: 620, y: 340, width: 20, height: 20},
    {x: 645, y: 360, width: 20, height: 20},
    {x: 670, y: 340, width: 20, height: 20},
    {x: 750, y: 380, width: 20, height: 20},
    {x: 770, y: 380, width: 20, height: 20},
    {x: 790, y: 380, width: 20, height: 20},
    {x: 750, y: 440, width: 20, height: 20},
    {x: 770, y: 440, width: 20, height: 20},
    {x: 790, y: 440, width: 20, height: 20},


    {x: 860, y: 400, width: 20, height: 20},
    {x: 860, y: 380, width: 20, height: 20},
    
    {x: 980, y: 380, width: 20, height: 20},
    ];
    const player = {
      x:200, y:480, width:20, height:20,
      Xv:0, Yv:0, gravity:500,
      onGround:false, friction:1200, speedMax:150,
      jumping:false, username:'', action:'idle'
    };

    const anim = { fw:64, fh:64, count:6, frame:0, row:0 };
    let lastTs = 0, frameTimer = 0, moving = false;

    // Login overlay
    document.getElementById('usernameBtn').onclick = () => {
      const name = document.getElementById('usernameInput').value.trim() || 'Player1';
      player.username = name;
      socket.emit('newâ€‘Player', { id: socket.id, name });
      document.getElementById('loginOverlay').style.display = 'none';
      canvas.focus();
    };

    // Collision helper
    function handleCollision(dt) {
      let acted = false;
      for (const b of boxes) {
        const bx = b.x, by = b.y, bw = b.width, bh = b.height;
        const px = player.x, py = player.y, pw = player.width, ph = player.height;
        // Top surface landing
        if (px + pw > bx && px < bx + bw &&
            py + ph <= by && py + ph + player.Yv*dt >= by) {
          player.y = by - ph; player.Yv = 0; player.onGround = true; acted = true;
        }
        // Left side
        if (px + pw <= bx && px + pw + player.Xv*dt >= bx &&
            py + ph > by && py < by + bh) {
          player.x = bx - pw; player.Xv = 0; acted = true;
        }
        // Right side
        if (px >= bx + bw && px + player.Xv*dt <= bx + bw &&
            py + ph > by && py < by + bh) {
          player.x = bx + bw; player.Xv = 0; acted = true;
        }
        // Underside bump
        if (px + pw > bx && px < bx + bw &&
            py >= by + bh && py + player.Yv*dt <= by + bh) {
          player.Yv = 10; acted = true;
        }
        if (acted) break;
      }
    }

    function update(dt) {
      frameTimer += dt;
      if (frameTimer >= 0.1) { anim.frame = (anim.frame + 1) % anim.count; frameTimer = 0; }
      player.onGround = false;
      player.Yv += player.gravity * dt;
      player.y += player.Yv * dt;

      handleCollision(dt);

      if (player.y + player.height >= canvas.height) {
        player.y = canvas.height - player.height;
        player.Yv = 0;
        player.onGround = true;
      }

      player.x = Math.max(0, Math.min(player.x + player.Xv * dt, canvas.width - player.width));

      if (player.onGround && !moving && Math.abs(player.Xv) < 30) {
        player.Xv = 0;
      } else if (!moving && player.Xv !== 0) {
        player.Xv += (player.Xv > 0 ? -player.friction : player.friction) * dt;
      }
    }

    function drawFrame() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      boxes.forEach(b => ctx.drawImage(imgs.box, b.x, b.y, b.width, b.height));
      const sprite = player.action === 'run' ? imgs.run : imgs.idle;
      ctx.drawImage(sprite,
        anim.frame * anim.fw, anim.row * anim.fh, anim.fw, anim.fh,
        player.x - 20, player.y - 20, anim.fw, anim.fh
      );
      ctx.font = '16px Arial';
      ctx.fillStyle = 'blue';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(player.username, player.x + player.width/2, player.y - 5);

      socket.emit('move', {
        x: player.x,
        y: player.y,
        frameCount: anim.count,
        frameIndex: anim.frame,
        frameRow: anim.row,
        username: player.username,
        emote: player.action
      });
    }

    canvas.addEventListener('keydown', e => {
      if (['ArrowLeft','ArrowRight','ArrowUp'].includes(e.key)) moving = true;
      if (e.key === 'ArrowUp' && player.onGround) {
        player.Yv = -200;
        player.jumping = true;
      }
      if (e.key === 'ArrowRight' && player.onGround) {
        player.action = 'run'; anim.count = 8; anim.row = 3;
        player.Xv = player.speedMax;
      }
      if (e.key === 'ArrowLeft' && player.onGround) {
        player.action = 'run'; anim.count = 8; anim.row = 2;
        player.Xv = -player.speedMax;
      }
    });

    canvas.addEventListener('keyup', e => {
      if (['ArrowLeft','ArrowRight','ArrowUp'].includes(e.key)) moving = false;
      if (e.key === 'ArrowUp') { player.jumping = false; }
      if (['ArrowLeft','ArrowRight'].includes(e.key)) {
        player.action = 'idle'; anim.frame = 0; anim.count = 6; anim.row = 0;
      }
    });

    function loop(ts) {
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;
      update(dt);
      drawFrame();
      requestAnimationFrame(loop);
    }

    loadImages(resources).then(() => {
      lastTs = performance.now();
      canvas.focus();
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
