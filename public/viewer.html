<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Control Your Character</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* Twitch behind */
    #twitchBg {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      border: 0;
      z-index: 0;
      pointer-events: none;
    }

    /* Canvas visually fullscreen, world stays fixed */
    #game {
      position: fixed;
      inset: 0;
      width: 50vw;
      height: 50vh;
      border: none;
      outline: none;
      z-index: 2;
      display: block;
      image-rendering: pixelated;
    }

    /* Overlay fullscreen */
    #loginOverlay {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 3;
      gap: 10px;
      padding: 20px;
      box-sizing: border-box;
    }

    #usernameInput {
      font-size: 20px;
      padding: 10px;
      width: min(600px, 70vw);
      max-width: 90vw;
    }

    #usernameBtn {
      font-size: 20px;
      padding: 10px 16px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <iframe
    id="twitchBg"
    src="https://player.twitch.tv/?channel=eberhex&parent=interactive-website-9620.onrender.com&muted=true"
    allowfullscreen="true"
    frameborder="0">
  </iframe>

  <!-- Playable area fixed at 1000x500 -->
  <canvas id="game" width="1000" height="500" tabindex="0"></canvas>

  <div id="loginOverlay">
    <input id="usernameInput" type="text" placeholder="Enter username" />
    <button id="usernameBtn" type="button">Go</button>
  </div>

  <script src="https://interactive-website-9620.onrender.com/socket.io/socket.io.js"></script>

  <script>
    console.log("GAME SCRIPT STARTED");
window.onerror = (msg, src, line, col, err) => {
  console.log("JS ERROR:", msg, "at", src, line + ":" + col, err);
};
    const socket = io("https://interactive-website-9620.onrender.com");

    // Fixed playable world
    const WORLD_W = 1000;
    const WORLD_H = 500;

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });

    // Lock internal resolution (do not change playable area)
    canvas.width = WORLD_W;
    canvas.height = WORLD_H;
    canvas.focus();

    // Asset loading flags
    const loaded = { box: false, idle: false, run: false, coin: false };

    // Assets
    const box_1_img = new Image();
    box_1_img.onload = () => loaded.box = true;
    box_1_img.src = '/assets/obstacles/box_1.png';

    const idleImg = new Image();
    idleImg.onload = () => loaded.idle = true;
    idleImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Idle/Slime1_Idle_body.png';

    const runImg = new Image();
    runImg.onload = () => loaded.run = true;
    runImg.src = '/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Run/Slime1_Run_body.png';

    const coinImg = new Image();
    coinImg.onload = () => loaded.coin = true;
    coinImg.src = '/assets/obstacles/coin.png';

    let img = idleImg;

    const animations = {
      frameWidth: 64,
      frameHeight: 64,
      frameCount: 6,
      currentFrame: 0,
      frameRow: 0
    };

    // World objects
    const boxes = [
      {x: 0, y: 400, width: 20, height: 20},
      {x: 80, y: 450, width: 20, height: 20},
      {x: 100, y: 450, width: 20, height: 20},
      {x: 120, y: 450, width: 20, height: 20},
      {x: 90, y: 350, width: 20, height: 20},
      {x: 110, y: 350, width: 20, height: 20},
      {x: 200, y: 400, width: 20, height: 20},
      {x: 300, y: 480, width: 20, height: 20},
      {x: 420, y: 420, width: 20, height: 20},
      {x: 440, y: 420, width: 20, height: 20},
      {x: 550, y: 380, width: 20, height: 20},
      {x: 620, y: 340, width: 20, height: 20},
      {x: 645, y: 360, width: 20, height: 20},
      {x: 670, y: 340, width: 20, height: 20},
      {x: 750, y: 380, width: 20, height: 20},
      {x: 770, y: 380, width: 20, height: 20},
      {x: 790, y: 380, width: 20, height: 20},
      {x: 750, y: 440, width: 20, height: 20},
      {x: 770, y: 440, width: 20, height: 20},
      {x: 790, y: 440, width: 20, height: 20},
      {x: 860, y: 400, width: 20, height: 20},
      {x: 860, y: 380, width: 20, height: 20},
      {x: 980, y: 380, width: 20, height: 20},
    ];

    const player = {
      x: 100,
      y: 480,
      width: 20,
      height: 20,
      Yv: 0,
      Yforce: 0,
      YforceMax: 0.5,
      Xv: 0,
      gravity: 500,
      onGround: false,
      friction: 1200,
      speedMax: 150,
      running: false,
      jumping: false,
      username: "",
      action: "idle",
      score: 0
    };

    // Scale+center world into the current window (NO CROPPING)
    function applyViewportTransform() {
      const scale = Math.min(window.innerWidth / WORLD_W, window.innerHeight / WORLD_H);
      const offsetX = (window.innerWidth - WORLD_W * scale) / 2;
      const offsetY = (window.innerHeight - WORLD_H * scale) / 2;
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
    }

    // Clear only the world canvas (reliable, avoids weird clears when scaled)
    function clearWorld() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, WORLD_W, WORLD_H);
      // Note: canvas is clipped to its own size anyway, so this is enough.
    }

    window.addEventListener('resize', () => draw());

    // Login overlay
    (function usernameprompt() {
      const overlay = document.getElementById('loginOverlay');
      const input = document.getElementById('usernameInput');
      const button = document.getElementById('usernameBtn');

      button.addEventListener('click', () => {
        const name = input.value.trim() || 'Player1';
        player.username = name;

        // Emit once connected
        socket.on('connect', () => {
          socket.emit('new-player', { id: socket.id, name });
        });

        overlay.style.display = 'none';
        canvas.focus();
      });
    })();

    let lastTime = performance.now();
    let frameTimer = 0;
    const frameInterval = 0.1;
    let animationStopper = false;

    let coin = null;
    socket.on("coin", data => {
      coin = data;
    });

    function update(deltaTime) {
      frameTimer += deltaTime;
      if (frameTimer >= frameInterval) {
        animations.currentFrame = (animations.currentFrame + 1) % animations.frameCount;
        frameTimer = 0;
      }

      for (const box of boxes) {
        const onBottom =
          player.y - player.height <= box.y - 1 &&
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y > box.y;

        const onTop =
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y + player.height <= box.y &&
          player.y + player.height + player.Yv * deltaTime >= box.y;

        const LeftSide =
          player.x + player.width >= box.x &&
          player.x + player.width <= box.x + box.width &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        const RightSide =
          player.x <= box.x + box.width &&
          player.x >= box.x &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        if (onTop) {
          player.y = box.y - player.height;
          player.Yv = 0;
          player.onGround = true;
          break;
        } else {
          player.onGround = false;
        }

        if (onBottom) player.Yv = 10;
        if (LeftSide) player.Xv = -80;
        if (RightSide) player.Xv = 80;
      }

      if (coin != null) {
        const coin_touching =
          player.x < coin.x + 10 &&
          player.x + player.width > coin.x &&
          player.y < coin.y + 10 &&
          player.y + player.height > coin.y;

        if (coin_touching) {
          coin = null;
          player.score++;
          socket.emit("coin_taken");
        }
      }

      if (!player.onGround) {
        player.Yv += player.gravity * deltaTime;
        player.y += player.Yv * deltaTime;
      }

      if (player.y + player.height >= WORLD_H) {
        player.y = WORLD_H - player.height;
        player.Yv = 0;
        player.onGround = true;
      }

      if (player.onGround) {
        if (player.jumping) player.Yforce += deltaTime;

        if (player.Xv >= -29 && player.Xv <= 29 && player.running === false) {
          player.Xv = 0;
          if (animationStopper === false) {
            img = idleImg;
            player.action = "idle";
            animations.currentFrame = 0;
            animations.frameCount = 6;
            animations.frameRow = 0;
            animationStopper = true;
          }
        }

        if (player.running === false && player.Xv > 0) player.Xv -= player.friction * deltaTime;
        else if (player.running === false && player.Xv < 0) player.Xv += player.friction * deltaTime;
      }

      player.x += player.Xv * deltaTime;

      if (player.x <= 0) {
        player.x = 0;
        player.Xv = 80;
      } else if (player.x + player.width >= WORLD_W) {
        player.x = WORLD_W - player.width;
        player.Xv = -80;
      }
    }

    function drawWorldObjects() {
      if (loaded.box) {
        for (const box of boxes) {
          ctx.drawImage(box_1_img, box.x - 5, box.y - 5, box.width + 12, box.height + 12);
        }
      } else {
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        for (const box of boxes) ctx.fillRect(box.x, box.y, box.width, box.height);
      }

      if (coin != null) {
        if (loaded.coin) ctx.drawImage(coinImg, coin.x, coin.y, 20, 20);
        else {
          ctx.fillStyle = "gold";
          ctx.fillRect(coin.x, coin.y, 20, 20);
        }
      }
    }

    function draw() {
      ctx.setTransform(1,0,0,1,0,0);
ctx.clearRect(0,0,canvas.width,canvas.height);
ctx.fillStyle = "rgba(0,255,255,0.3)";
ctx.fillRect(0,0,1000,500);
ctx.fillStyle = "yellow";
ctx.font = "24px Arial";
ctx.fillText("DRAW LOOP RUNNING", 10, 30);
      clearWorld();
      applyViewportTransform();

      // faint background so you can see the world bounds
      console.log("background")
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(0, 0, WORLD_W, WORLD_H);

      drawWorldObjects();
      console.log("drawobjects")
      // Player sprite fallback
      if (loaded.idle) {
        console.log("player idle")
        ctx.drawImage(
          img,
          animations.currentFrame * animations.frameWidth,
          animations.frameRow * animations.frameHeight,
          animations.frameWidth, animations.frameHeight,
          player.x - 20, player.y - 20,
          animations.frameWidth, animations.frameHeight
        );
      } else {
        ctx.fillStyle = "lime";
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }

      // Text
      ctx.font = '16px Arial';
      ctx.fillStyle = 'deepskyblue';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(player.username || "Player", player.x + player.width / 2, player.y - 5);

      ctx.textAlign = 'left';
      ctx.fillText("Current score: " + player.score, 10, WORLD_H - 10);

      socket.emit("move", {
        x: player.x,
        y: player.y,
        frameCount: animations.frameCount,
        frameIndex: animations.currentFrame,
        frameRow: animations.frameRow,
        username: player.username,
        emote: player.action,
        score: player.score
      });
    }

    function gameLoop(currentTime) {
      console.log("Game loop running")
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      update(deltaTime);
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Input
    canvas.addEventListener('keydown', e => {
      if (e.key === "ArrowRight" && player.onGround) {
        player.action = "run";
        if (player.running === false) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 3;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = player.speedMax;
      }

      if (e.key === "ArrowLeft" && player.onGround) {
        player.action = "run";
        if (player.running === false) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 2;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = -1 * player.speedMax;
      }

      if (e.key === "ArrowUp") {
        if (player.onGround === true) player.jumping = true;
      }
    });

    canvas.addEventListener('keyup', e => {
      if (e.key === "ArrowRight") player.running = false;
      if (e.key === "ArrowLeft") player.running = false;

      if (e.key === "ArrowUp") {
        if (player.onGround) {
          player.jumping = false;
          player.onGround = false;
          if (player.Yforce > player.YforceMax) player.Yforce = player.YforceMax;
          player.Yv -= player.Yforce * 180 + 200;
          player.Yforce = 0;
        }
      }
    });

    // Keep focus on canvas
    window.addEventListener('click', () => canvas.focus());

    // Start loop immediately
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>









