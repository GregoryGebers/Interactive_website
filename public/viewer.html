<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game (Fixed World, Scaled View)</title>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    /* Twitch behind everything */
    #twitchBg {
      position: fixed;
      inset: 0;
      width: 50vw;
      height: 50vh;
      border: 0;
      z-index: 0;
      pointer-events: none;
    }

    /* Canvas above Twitch */
    #game {
      position: fixed;
      inset: 0;
      width: 50vw;
      height: 50vh;
      z-index: 10;
      display: block;
      border: 0;
      outline: 0;
      image-rendering: pixelated;
      background: rgba(0,0,0,0.01);
    }

    #loginOverlay {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.5);
      z-index: 20;
      gap: 10px;
      padding: 20px;
      box-sizing: border-box;
    }

    #usernameInput {
      font-size: 20px;
      padding: 10px;
      width: min(600px, 70vw);
      max-width: 90vw;
    }

    #usernameBtn {
      font-size: 20px;
      padding: 10px 16px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <!-- Twitch embed (errors here won't stop the game) -->
  <iframe
    id="twitchBg"
    src="https://player.twitch.tv/?channel=eberhex&parent=interactive-website-9620.onrender.com&muted=true"
    allowfullscreen="true"
    frameborder="0">
  </iframe>

  <!-- Fixed playable world size -->
  <canvas id="game" width="1000" height="500" tabindex="0"></canvas>

  <div id="loginOverlay">
    <input id="usernameInput" type="text" placeholder="Enter username" />
    <button id="usernameBtn" type="button">Go</button>
  </div>

  <script src="https://interactive-website-9620.onrender.com/socket.io/socket.io.js"></script>
  <script>
    console.log("GAME SCRIPT STARTED");
    window.onerror = (msg, src, line, col, err) => {
      console.log("JS ERROR:", msg, "at", src, line + ":" + col, err);
    };

    // ===== Fixed playable world (DO NOT CHANGE) =====
    const WORLD_W = 1000;
    const WORLD_H = 500;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    canvas.width = WORLD_W;
    canvas.height = WORLD_H;
    canvas.focus();

    // Safe socket (won't break game if socket fails)
    let socket = null;
    try {
      if (typeof io === "function") socket = io("https://interactive-website-9620.onrender.com");
    } catch (e) {
      console.log("Socket init failed (safe):", e);
    }

    // ===== Load images safely with flags + error logging =====
    const loaded = { box: false, idle: false, run: false, coin: false };

    function loadImage(src, flagName) {
      const im = new Image();
      im.onload = () => { loaded[flagName] = true; };
      im.onerror = () => { console.log("IMAGE FAILED:", src); };
      im.src = src;
      return im;
    }

    const box_1_img = loadImage("/assets/obstacles/box_1.png", "box");
    const idleImg  = loadImage("/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Idle/Slime1_Idle_body.png", "idle");
    const runImg   = loadImage("/assets/characters/craftpix-net-879657-free-slime-mobs-pixel-art-top-down-sprite-pack/PNG/Slime1/Run/Slime1_Run_body.png", "run");
    const coinImg  = loadImage("/assets/obstacles/coin.png", "coin");

    let img = idleImg;

    const animations = {
      frameWidth: 64,
      frameHeight: 64,
      frameCount: 6,
      currentFrame: 0,
      frameRow: 0
    };

    // World objects (always exist)
    const boxes = [
      {x: 0, y: 400, width: 20, height: 20},
      {x: 80, y: 450, width: 20, height: 20},
      {x: 100, y: 450, width: 20, height: 20},
      {x: 120, y: 450, width: 20, height: 20},
      {x: 90, y: 350, width: 20, height: 20},
      {x: 110, y: 350, width: 20, height: 20},
      {x: 200, y: 400, width: 20, height: 20},
      {x: 300, y: 480, width: 20, height: 20},
      {x: 420, y: 420, width: 20, height: 20},
      {x: 440, y: 420, width: 20, height: 20},
      {x: 550, y: 380, width: 20, height: 20},
      {x: 620, y: 340, width: 20, height: 20},
      {x: 645, y: 360, width: 20, height: 20},
      {x: 670, y: 340, width: 20, height: 20},
      {x: 750, y: 380, width: 20, height: 20},
      {x: 770, y: 380, width: 20, height: 20},
      {x: 790, y: 380, width: 20, height: 20},
      {x: 750, y: 440, width: 20, height: 20},
      {x: 770, y: 440, width: 20, height: 20},
      {x: 790, y: 440, width: 20, height: 20},
      {x: 860, y: 400, width: 20, height: 20},
      {x: 860, y: 380, width: 20, height: 20},
      {x: 980, y: 380, width: 20, height: 20},
    ];

    const player = {
      x: 100,
      y: 480,
      width: 20,
      height: 20,
      Yv: 0,
      Yforce: 0,
      YforceMax: 0.5,
      Xv: 0,
      gravity: 500,
      onGround: false,
      friction: 1200,
      speedMax: 150,
      running: false,
      jumping: false,
      username: "",
      action: "idle",
      score: 0
    };

    // ===== IMPORTANT FIX: viewport size must never be 0 =====
    function getViewportSize() {
      const w = Math.max(1,
        window.innerWidth || 0,
        document.documentElement.clientWidth || 0,
        document.body ? document.body.clientWidth : 0
      );
      const h = Math.max(1,
        window.innerHeight || 0,
        document.documentElement.clientHeight || 0,
        document.body ? document.body.clientHeight : 0
      );
      return { w, h };
    }

    function applyViewportTransform() {
      const { w, h } = getViewportSize();
      const scale = Math.min(w / WORLD_W, h / WORLD_H);
      const offsetX = (w - WORLD_W * scale) / 2;
      const offsetY = (h - WORLD_H * scale) / 2;
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      return { scale, offsetX, offsetY, w, h };
    }

    function clearScreen() {
      // Clear in identity space
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const { w, h } = getViewportSize();
      ctx.clearRect(0, 0, w, h);
    }

    // ===== Login overlay =====
    const overlay = document.getElementById("loginOverlay");
    const input = document.getElementById("usernameInput");
    const button = document.getElementById("usernameBtn");
    button.addEventListener("click", () => {
      const name = input.value.trim() || "Player1";
      player.username = name;

      if (socket) {
        socket.on("connect", () => socket.emit("new-player", { id: socket.id, name }));
      }
      overlay.style.display = "none";
      canvas.focus();
    });

    // Coin
    let coin = null;
    if (socket) {
      socket.on("coin", data => coin = data);
    }

    // Timing
    let lastTime = performance.now();
    let frameTimer = 0;
    const frameInterval = 0.1;
    let animationStopper = false;

    function update(dt) {
      frameTimer += dt;
      if (frameTimer >= frameInterval) {
        animations.currentFrame = (animations.currentFrame + 1) % animations.frameCount;
        frameTimer = 0;
      }

      // collisions
      for (const box of boxes) {
        const onBottom =
          player.y - player.height <= box.y - 1 &&
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y > box.y;

        const onTop =
          player.x + player.width > box.x &&
          player.x < box.x + box.width &&
          player.y + player.height <= box.y &&
          player.y + player.height + player.Yv * dt >= box.y;

        const LeftSide =
          player.x + player.width >= box.x &&
          player.x + player.width <= box.x + box.width &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        const RightSide =
          player.x <= box.x + box.width &&
          player.x >= box.x &&
          player.y + 4 <= box.y + box.height &&
          player.y + player.height - 1 >= box.y;

        if (onTop) {
          player.y = box.y - player.height;
          player.Yv = 0;
          player.onGround = true;
          break;
        } else {
          player.onGround = false;
        }

        if (onBottom) player.Yv = 10;
        if (LeftSide) player.Xv = -80;
        if (RightSide) player.Xv = 80;
      }

      // coin
      if (coin != null) {
        const touching =
          player.x < coin.x + 10 &&
          player.x + player.width > coin.x &&
          player.y < coin.y + 10 &&
          player.y + player.height > coin.y;

        if (touching) {
          coin = null;
          player.score++;
          if (socket) socket.emit("coin_taken");
        }
      }

      // gravity
      if (!player.onGround) {
        player.Yv += player.gravity * dt;
        player.y += player.Yv * dt;
      }

      // floor
      if (player.y + player.height >= WORLD_H) {
        player.y = WORLD_H - player.height;
        player.Yv = 0;
        player.onGround = true;
      }

      // friction + idle
      if (player.onGround) {
        if (player.jumping) player.Yforce += dt;

        if (player.Xv >= -29 && player.Xv <= 29 && player.running === false) {
          player.Xv = 0;
          if (!animationStopper) {
            img = idleImg;
            player.action = "idle";
            animations.currentFrame = 0;
            animations.frameCount = 6;
            animations.frameRow = 0;
            animationStopper = true;
          }
        }

        if (!player.running && player.Xv > 0) player.Xv -= player.friction * dt;
        else if (!player.running && player.Xv < 0) player.Xv += player.friction * dt;
      }

      // move X
      player.x += player.Xv * dt;

      if (player.x <= 0) { player.x = 0; player.Xv = 80; }
      else if (player.x + player.width >= WORLD_W) { player.x = WORLD_W - player.width; player.Xv = -80; }
    }

    function draw() {
      clearScreen();
      const vp = applyViewportTransform();

      // VERY visible world background + border (you cannot miss it)
      ctx.fillStyle = "rgba(0, 255, 255, 0.25)";
      ctx.fillRect(0, 0, WORLD_W, WORLD_H);

      ctx.strokeStyle = "yellow";
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, WORLD_W - 4, WORLD_H - 4);

      // Debug text proving transform values
      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      ctx.fillText(`VIEW: ${vp.w}x${vp.h}  scale:${vp.scale.toFixed(3)}  off:${vp.offsetX.toFixed(1)},${vp.offsetY.toFixed(1)}`, 10, 22);
      ctx.fillText("If you see this, rendering is working.", 10, 42);

      // Boxes (always draw something)
      if (loaded.box) {
        for (const b of boxes) ctx.drawImage(box_1_img, b.x - 5, b.y - 5, b.width + 12, b.height + 12);
      } else {
        ctx.fillStyle = "white";
        for (const b of boxes) ctx.fillRect(b.x, b.y, b.width, b.height);
      }

      // Coin
      if (coin != null) {
        if (loaded.coin) ctx.drawImage(coinImg, coin.x, coin.y, 20, 20);
        else {
          ctx.fillStyle = "gold";
          ctx.fillRect(coin.x, coin.y, 20, 20);
        }
      }

      // Player (always draw something)
      if (loaded.idle) {
        ctx.drawImage(
          img,
          animations.currentFrame * animations.frameWidth,
          animations.frameRow * animations.frameHeight,
          animations.frameWidth, animations.frameHeight,
          player.x - 20, player.y - 20,
          animations.frameWidth, animations.frameHeight
        );
      } else {
        ctx.fillStyle = "red";
        ctx.fillRect(player.x, player.y, player.width, player.height);
      }

      // HUD
      ctx.fillStyle = "white";
      ctx.textAlign = "left";
      ctx.fillText(`Score: ${player.score}`, 10, WORLD_H - 10);

      if (socket) {
        socket.emit("move", {
          x: player.x, y: player.y,
          frameCount: animations.frameCount,
          frameIndex: animations.currentFrame,
          frameRow: animations.frameRow,
          username: player.username,
          emote: player.action,
          score: player.score
        });
      }
    }

    function loop(t) {
      const dt = (t - lastTime) / 1000;
      lastTime = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Input
    canvas.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight" && player.onGround) {
        player.action = "run";
        if (!player.running) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 3;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = player.speedMax;
      }

      if (e.key === "ArrowLeft" && player.onGround) {
        player.action = "run";
        if (!player.running) {
          img = runImg;
          animations.currentFrame = 0;
          animations.frameCount = 8;
          animations.frameRow = 2;
          animationStopper = false;
        }
        player.running = true;
        player.Xv = -player.speedMax;
      }

      if (e.key === "ArrowUp") {
        if (player.onGround) player.jumping = true;
      }
    });

    canvas.addEventListener("keyup", (e) => {
      if (e.key === "ArrowRight" || e.key === "ArrowLeft") player.running = false;

      if (e.key === "ArrowUp") {
        if (player.onGround) {
          player.jumping = false;
          player.onGround = false;
          if (player.Yforce > player.YforceMax) player.Yforce = player.YforceMax;
          player.Yv -= player.Yforce * 180 + 200;
          player.Yforce = 0;
        }
      }
    });

    window.addEventListener("click", () => canvas.focus());
    window.addEventListener("resize", () => draw());

    requestAnimationFrame(loop);
  </script>
</body>
</html>







